1. 디자인 패턴이란 <br>

    먼저, 디자인 패턴은 소프트웨어를 설계할때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용 할 수 있는 훌륭한 해결책임.
    이미 만들어진 것을 처음부터 다시 만들 필요가 없다는 의미임.
    패턴이란 각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에서도 공통점이 있는데 이 유사점을 패턴이라고 함.
    패턴은 공통의 언어를 만들어주며, 팀원 사이의 의사 소통을 원할하게 해주는 아주 중요한 역할을 함.

    디자인 패턴의 분류는 3가지로 나뉨.
    생성(Creational), 구조(Structural), 행위(Behavioral)로 나뉘는데 
    먼저, 생성 패턴은
    객체의 생성에 관련된 패턴이고, 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공하는 특징이 있음.
    구조 패턴은
    클래스나 객체를 조합해 더 큰 구조를 만드는 패턴이며, 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴임
    행위 패턴은 
    객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴이고, 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화 하는것에 중점을 두는 것임.

    다음으로 디자인 패턴의 대표적인 14가지 방식에 대해 알아보겠다. 

    먼저 생성 패턴에는<br>

        1) 추상 팩토리(ABstract Factory)
        
        특정한 상황이나 다양한 구성 요소 별로 객체의 집합을 생성할 때 유용함.
        관련성 있는 객체들을 일관된 방식으로 생성하는 경우에 유용함.
        추상 팩토리 패턴을 사용하면 클라이언트에서 추상 인터페이스를 통해 객체들을 제공 받음. 이때, 사용자는 어떤 객체가 생성되는지 알 수 없고, 알 필요도 없기 때문에 객체를 분리시킬 수 있음
        추상 인터페이스에 있는 묶음으로만 새로운 객체를 생성할 수 있어 객체 생성에 제약적임.
        예를들어, 각 회사마다 보유하고 있는 핸드폰 브랜드가 있는데, 삼성은 엘지 휴대폰을 만들고 싶어도 포함되어 있지 않아서 만들 수 없음.

        2) 팩토리 메소드(Factory Method)
        
        부모 클래스에 알려지지 않은 클래스를 생성하는 패턴으로, 자식 클래스가 객체 생성을 결정하도록 하는 패턴임.
        객체 생성 코드를 클래스나 메소드로 분리해 객체 생성 변화에 대비할 수 있음.
        객체만 생성하는 Factory를 통해서 객체를 새성해 자식 클래스에서 구현이 되므로 유지보수가 용이해 객체 간의 결합도가 낮아짐.
        자식 클래스를 계속 추가로 정의해 클래스가 많아져 복잡해질 수 있음.

        3) 싱글턴 (Singleton) 

        1개의 인스턴스만 생성해 사용하는 패턴임.
        특정 클래스가 최초 1번만 메모리를 할당해 그 메모리에 인스턴스를 만들어 사용하는 패턴임.
        생성된 인스턴스는 전역이기 때문에 여러 스레드가 공유해 사용할 수 있기 때문에 효율성을 높일 수 있음.
        메모리 낭비를 방지할 수 있음.
        클래스 내부에서 직접 생성해 ocp나 dip를 위배할 수 있음


        4)빌더(Builder)
        
        복잡한 객체를 단계별로 구성할 수 있는 작성 설계 패턴임.
        별도의 Builder 클래스를 만들어 필수값은 생성자로, 선택값은 메소드를 통해 단계별로 값을 입력받은 후 build()메소드로 하나의 인스턴스를 리턴하는 방식임.
        필드에 값을 세팅한 후, 객체를 생성하고 나서 변경 불가능한 상태로 만듬.
        코드가 길지만. 롬복으로 빌더 패턴을 적용시킬 수 있음.

        5) 프로토타입(Prototype)

        코드를 클래스에 종속시키지 않고 기존 객체를 복사할 수 있는 패턴임.
        인스턴스 만드는 절차를 추상화함.
        객체를 생성하는데 시간이 많이 소모되고, 유사한 객체게 존재하는 경우에 원형을 복사해 새로운 객체를 생성함.
        예를들어, db에서 데이터를 가져올 때 매번 가져오는 것보다 한번만 가져와 객체에 저장해 복사하면 훨씬 효율적임.


    다음으로 구조 패턴은

        1) 적응자(Adapter)

        클래스의 인터페이스를 다른 인터페이스로 변환해 객체 간 상호 협력할 수 있도록 하는 패턴임
        같이 쓸 수 없는 클래스들을 연결해 사용 가능.
        상속을 사용한 Adapter과 위임을 사용한 Adapter이 있음
        클래스를 연결하다 보니 계속 증가시키다 보면 복잡도가 증가할 수 있음.
        예를 들어, 220을 110v 콘센트에서도 사용 가능하게 하는 변환기(어뎁터)

        2)가교(Bridge)

        클래스들을 추상화와 구현이라는 별도의 계층으로 분할해주는 패턴임
        객체의 다중 상속 구조를 피하면서 독립적으로 변형 및 확장이 가능함
        클라이언트로부터 구현 부분을 숨기고 싶을 때 사용함.
        확장과 동시에 구조가 복잡해질 수 있음

        3)복합체(Composite)

        폴더 구조(트리 패턴)
        계층적 구조화를 통해 객체를 확장하는 패턴
        하나의 요소를 관리하듯 전체 요소를 관리할 수 있는 일괄적으로 관리가 가능해짐
        트리 구조이기 때문에 깊이가 깊어질수록 디버깅이 힘들 수 있음.

        4)퍼사드(Facade)
        
        복잡한 서브시스템을 쉽게 사용할 수 있도록 인터페이스로 감싸는 패턴
        클라이언트는 서브시스템의 존재를 모르고 facade의 존재만 암
        클라이언트는 서브시스템들의 동작을 생각할 필요 없이 명령만 하면 동작함.
        예를들어 전자레인지는 버튼을 누르면 음식에 맞게 동작함 ->단순한 버튼으로 동작할 수 있는 편리한 인터페이스 제공

        5) 플라이급(Flyweight)

        여러 객체 간에 공통적인 상태 부분을 공유하여 사용 가능한 Ram에 더 많은 객체를 넣을 수 있는 패턴
        동일한 객체를 자주 사용할 때, 매번 생성하지 않고 object pool에 저장해 재활용함
        메모리와 시간이 절약됨.
        데이터를 공유하면서 사용하도록 구현되어 있어서 일부 객체 동작을 변경시키기 힘듬

        6) 장식자(Decorator)

        주어진 상황이나 용도에 따라 객체에 책임을 덧붙이는 패턴(동적 추가 기능)
        계속해서 데코레이터 클래스들이 추가되어 많아질 수 있음
        예를들어 카페에서 주문 시 시럽, 샷 등 기호에 따라 추가되거나 삭제되어야 하는 경우 사용

        7)프록시(Proxy)

        어떤 일을 대신 처리하는 패턴(비서)
        객체를 직접 참조하는 것이 아니라, 비서를 통해 대상 객체에 접근하는 방식
        해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정이 가능함
        계속 비서를 거치기 떄문에 객체를 게속 로딩해 성능이 저하될 수 있음
        예를들어, 화면에 텍스느타 그림을 로딩하는 경우 그림이 늦게 로딩되기 때문에 텍스트와 그림을 같이 보여주려면 시간이 오래 걸림. 텍스트를 먼저 보여줌으로써 사용자가 무조건 기다리지 않도록 하는 것, 즉 텍스트 처리용과 그림 처리용을 따로 운영하는 구조가 프록시 패턴임

    다음으로 행위 패턴은
        
        1)책임 연쇄(chain of responsibility)
        
        집단으로 지내다 보면 어떤 일에 대해 서로 책임을 떠넘겼던 경우가 있다. 이렇게 책임자를 찾을 때까지 요구가 넘겨지는 것이 '책임 떠넘기기'
        클라이언트로부터 요청이 들어왔을 때 직접 경정할 수 없는 경우, 객체를 chain 처럼 연결해 돌아다니면서 객체를 결정하는 방법임
        요청을 처리할 수 있는 객체가 여러개이고 처리 각체가 특징적이지 않을 경우 권장됨.
        요청 보내는 행동을 어던 객체게 할지 모르기 때문에 항상 요청이 처리되지는 않음.

        2) 명렁(command)

        요청에 따라야 하는 기능들을 캡슐화 한 객체에 정리해 실행할 수 있게 해주는 패턴임
        클래스는 메소드를 호출해 일을 시작하는데, 호출한 결과는 객체의 상태에 반영되지만 이력은 남지 않음
        이때, 실행하고 남은 일(명령)을 클래스의 인스턴스로 하나의 물건 처럼 표현하는 것임.
        해당 인스턴스의 집합을 관리해 명령을 재실행할 수 있음
        단, 각 명령을 위한 클래스가 많아질 수 있음

        3) 해석자(interpreter)

        문법 규칙을 클래스화한 구조
        사용자가 표현하기 쉬운 표현을 사용하게 하고, 이를 해석하는 객체를 통해 약속된 알고리즘을 수행할 수 있게 해주는 패턴
        sql 쿼리문 등을 실행할 때 필요한 인자를 전달하는 경우에 사용됨.
        각 규칙별로 클래스가 정의되어 있기 때문에 많은 규칙이 있을 경우 관리가 어려움.

        4)반복자(iterator)

        객체의 집합을 순서대로 명령을 처리할 수 있게 해주는 패턴
        즉, 순서대로 하나하나 전체를 검색하는 처리를 실행하는 것
        순서대로 구분해 가독성과 재사용성을 높이지만 구조가 복잡해 질 수 있음

        5)중재자(mediator)

        여러 명이서 공동 작업을 하고 있는 경우 서로 지시를 하면 일이 진행되지 않음
        이때, 중재자가 등장해 보고를 받고 동료들에게 지시하면 혼란은 없어짐
        이처럼 객체들 간의 상호작용 행위를 모아논 객체인 중재자가 관리하는 패턴
        객체들 간의 관계가 복잡해 재사용에 부담이 있는 경우 사용

        6)메멘토(memento)

        되돌리기, 저장 역할
        객체 상태 정보를 가지는 클래스를 생성해, 저장하거나 이전 상태로 되돌릴 수 있게 해주는 패턴
        계속 상태를 저장하다 보니 많은 메모리가 필요한 경우도 있음
        그래서 복구하는데 시간이 오래 걸릴 수 있음

        7)관찰자(Observer)

        관잘차 객체를 생성해 객체들의 상태 변화를 관리하는 패턴
        관찰자 한개가 여러 객체들을 관찰하기 댸문에 일대 다 구조이며 객체의 변화가 생기면 종속 객체들이 자동으로 변화에 따른 명령을 수행하도록 함
        실시간으로 효과적으로 데이터를 배분할 수 있음
        데이터 배분에 문제가 생기면 문제가 파급력이 커짐

        8)상태(State)

        상태를 클래스로 표현
        객체 내부의 상태에 따라 동작을 변경해야 할 때 사용함
        한 객체가 다양한 동작이 필요할 때 상태 객체만 수정하면 됨 즉, 수정이 간편함
        관리해야 할 클래스가 증가해 관리가 어려울 수 있음.

        9)전략 (Strategy)

        문제를 해결하기 위한 전략(Strategy)을 교환할 수 있는 패턴
        상황에 따라 필요한 전략을 교체해 동일한 문제여도 다른 방법으로 쉽게 해결이 가능하다!
        각 전략들에 따라 객체 수가 증가할 수 있다.

        10) Template Method

        부모 클래스에서 처리를 제어하고, 자식 클래스에서 처리 내용을 구체화하는 패턴
        공통되는 사항은 부모 클래스에서 구현하고, 다른 부분은 자식 클래스에서 구현한다.
        상속 관계를 활용하기 때문에 코드 중복이 줄어든다.
        하지만, 부모 클래스가 많아지면서 관리가 복잡할 수 있다.

        11)방문자  (Visitor)

        데이터 구조에는 많은 요소가 있는데, 이를 처리하기 위한 코드가 필요하다. 보통은 클래스 안에 기술하지만, 처리의 종류가 많아지면 그때마다 클래스를 수정할 필요가 있음.
        이를 방지하기 위해 데이터 구조와 처리를 분리하고, 방문자(Visitor) 클래스를 만들어 처리를 위임한다.
        그래서 수정이 필요할 때 각 클래스를 수정하지 않고, 방문자 클래스만 변경하면 된다.
        하지만, 방문자 클래스에 로직이 많으면 유지보수가 어려움.



